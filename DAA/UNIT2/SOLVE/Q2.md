<img width="683" height="373" alt="image" src="https://github.com/user-attachments/assets/8267f60c-ac1d-46be-a9fc-8491a3d497e3" />


***

### Best Case Analysis: $O(n)$

The **best-case** scenario occurs when the input array is **already sorted** in ascending order.

* **Analysis**: When the array is sorted, the outer `for` loop still runs `n` times. However, for each element `key = a[i]`, the inner `while` loop condition (`a[j] > key`, where `j = i-1`) is tested only once and immediately fails. This is because `a[j]` will always be less than or equal to `key` in a sorted array. As a result, the body of the `while` loop, which performs the shifting, is never executed.
* **Complexity**: The algorithm just performs a constant number of operations for each of the `n` elements. Therefore, the total time is directly proportional to `n`, giving a linear time complexity of **$O(n)$**.

***

### Worst Case Analysis: $O(n^2)$

The **worst-case** scenario happens when the array is sorted in **reverse (descending) order**.

* **Analysis**: In this situation, for each pass `i` of the outer loop, the `key = a[i]` is the smallest element compared to all elements in the sorted subarray to its left (`a[0]` to `a[i-1]`). Consequently, the inner `while` loop must compare the `key` with every single element in the sorted portion and shift all of them one position to the right to make space for the `key` at the very beginning.
    * The number of comparisons forms a series: $1 + 2 + 3 + \dots + (n-1)$.
    * The sum of this series is $\frac{(n-1)n}{2}$, which simplifies to $\frac{n^2 - n}{2}$.
* **Complexity**: As `n` grows large, the $n^2$ term dominates the function. Thus, the worst-case time complexity is **$O(n^2)$**.

***

### Average Case Analysis: $O(n^2)$

The **average-case** scenario assumes the elements in the array are in a **random, jumbled order**.

* **Analysis**: To analyze the average case, we consider the `key = a[i]` being inserted into the already sorted subarray `a[0...i-1]`. This subarray contains `i` elements. When inserting the `key`, there are `i+1` possible positions it could land in (from the very beginning, before `a[0]`, to the end, after `a[i-1]`).

    Assuming a random distribution of values, the `key` is equally likely to be inserted into any of these `i+1` positions. On average, we can expect the `key` to be inserted into the middle of the sorted subarray. To do this, the `while` loop would have to compare and shift about half of the elements in the sorted subarray.

    So, for each pass `i`, the number of comparisons is approximately $\frac{i}{2}$. To find the total average number of comparisons, we sum this for all passes of the outer loop:
    $$\text{Total Comparisons} \approx \sum_{i=1}^{n-1} \frac{i}{2} = \frac{1}{2} \sum_{i=1}^{n-1} i$$
    This sum is calculated as:
    $$\frac{1}{2} \left( \frac{(n-1)n}{2} \right) = \frac{n^2 - n}{4}$$
* **Complexity**: Although the constant factor (1/4) is smaller than in the worst case (1/2), the function's growth is still dominated by the $n^2$ term. Therefore, the average-case time complexity is also **$O(n^2)$**.

### Summary

| Case | Input Data Condition | Time Complexity |
| :--- | :--- | :--- |
| **Best Case** | Already sorted in ascending order | $O(n)$ |
| **Average Case**| Randomly ordered | $O(n^2)$ |
| **Worst Case** | Sorted in descending order | $O(n^2)$ |
